package ru.itmo.ale.Characters;

import java.util.Objects;

import ru.itmo.ale.Enums.Emotion;
import ru.itmo.ale.Interfaces.Emotions;
import ru.itmo.ale.Interfaces.Eater;
import ru.itmo.ale.Locations.DiningRoom;
import ru.itmo.ale.Locations.Location;
import ru.itmo.ale.Objects.CabbageRoll;
import ru.itmo.ale.Objects.Meal;

/**
 * Base astratta per i personaggi del gioco.
 * Incapsula stato (nome, umore, piega) e posizione.
 */
public abstract class Character implements Emotions, Eater {

    private String name;
    private Emotion mood;
    private boolean hasCrease;
    private Location currentLocation;

    public Character(String name, Location location) {
        this.name = Objects.requireNonNull(name, "name must not be null");
        this.currentLocation = Objects.requireNonNull(location, "location must not be null");
        this.mood = Emotion.NORMAL;
        this.hasCrease = false;
        this.currentLocation.addCharacter(this);
    }

    // --- accessors ---
    public String getName() { return name; }
    public void setName(String name) {
        this.name = Objects.requireNonNull(name, "name must not be null");
    }

    public Emotion getMood() { return mood; }

    public Location getCurrentLocation() { return currentLocation; }

    protected void setCurrentLocation(Location location) {
        this.currentLocation = Objects.requireNonNull(location, "location must not be null");
    }

    // Sposta il personaggio (implementazione demandata alle sottoclassi).
    public abstract void moveTo(Location location);

    // --- comportamenti di Eater ---
    @Override
    public boolean eats(Meal meal) {
        Objects.requireNonNull(meal, "meal must not be null");

        if (currentLocation instanceof DiningRoom) {
            System.out.println(String.format("%s eats %s", name, meal.getName()));
            // rimuove il piatto dal tavolo; il risultato indica se è stato davvero rimosso
            boolean removed = ((DiningRoom) currentLocation).getTable().removeMeal(meal);
            if (!removed) {
                System.out.println(String.format("But %s couldn't find %s on the table", name, meal.getName()));
            }
            return removed;
        } else {
            System.out.println(String.format(
                "%s can't eat because %s is not in the Dining room",
                name, (name.endsWith("s") ? "they are" : "he is")
            ));
            return false;
        }
    }

    // N.B.: correggo il typo "Cabagge" -> "Cabbage"
    public Meal divideCabbageRoll(CabbageRoll roll) {
        Objects.requireNonNull(roll, "roll must not be null");
        System.out.println(String.format("%s unrolls %s", name, roll.getName()));
        return roll.unrollCabbage();
    }

    // Mantengo la firma ma rendo il metodo più robusto.
    public void setMood(Emotion emotion, String reason) {
        this.mood = Objects.requireNonNull(emotion, "emotion must not be null");
        String why = (reason == null || reason.isBlank()) ? "no reason given" : reason;
        System.out.println(String.format("%s changes to %s because %s", name, emotion, why));
    }

    /**
     * Aggiorna lo stato della piega in base all'umore corrente.
     * Nota: il nome originale "setCrease" era fuorviante; lascio la firma
     * per retrocompatibilità ma rendo l'effetto deterministico.
     */
    public void setCrease() {
        boolean shouldHaveCrease;
        switch (mood) {
            case ANGRY:
            case SAD:
            case SUSPICIOUS:
                shouldHaveCrease = true;
                break;
            default:
                shouldHaveCrease = false;
        }

        if (this.hasCrease != shouldHaveCrease) {
            this.hasCrease = shouldHaveCrease;
            if (hasCrease) {
                System.out.println(String.format("A crease has appeared on %s", name));
            } else {
                System.out.println(String.format("The crease disappeared on %s", name)); // fix: disappeared
            }
        } else {
            System.out.println(String.format("%s %s the crease", name, hasCrease ? "still has" : "doesn't have"));
        }
    }

    @Override
    public String toString() {
        String locationName = (currentLocation != null ? currentLocation.getName() : "<nowhere>");
        return String.format("Name: %s, Mood: %s, has crease: %s, location: %s",
                name, mood, hasCrease, locationName);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Character)) return false;
        Character other = (Character) obj;
        return hasCrease == other.hasCrease
                && mood == other.mood
                && Objects.equals(name, other.name)
                && Objects.equals(currentLocation, other.currentLocation);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, mood, hasCrease, currentLocation);
    }
}

cosa ho migliorato (e perché)
Null-safety e validazioni: uso Objects.requireNonNull in punti chiave (costruttore, setter, metodi pubblici) per evitare NPE “silenziosi”.
Incapsulamento: i campi sono private. Espongo getter/setter dove serve e un protected setCurrentLocation utile alle sottoclassi in moveTo.
Ritorni coerenti: in eats ora il return è informativo: true solo se il Meal è effettivamente rimosso dal tavolo. Nel ramo “non sono in sala da pranzo” ritorna false (prima ritornava true, bug logico).
Messaggi e typo: corretti i testi (“disappeared”) e l’inglese; gestito gentilmente il pronome nel messaggio. Sistemato il nome del metodo in divideCabbageRoll (era “Cabagge”).
setCrease reso deterministico: prima non “set-tava”, ma faceva un po’ di branching con early-return e side-effect inconsistenti. Ora calcola lo stato atteso dalla mood e aggiorna solo se cambia, loggando il risultato. Mantengo il nome per compatibilità.
toString robusto: non va in NPE se la location è null (per sicurezza).
equals/hashCode: stessi campi della tua versione, ma con Objects.equals anche per location così è null-safe. (Nota: includere location e mood nell’identità è una scelta; se un “personaggio” dovrebbe essere identificato solo dal nome, potresti semplificare basandoti su name e getClass()).
Formattazione: uso String.format per messaggi più puliti e consistenti.